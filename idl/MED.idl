//  Copyright (C) 2003  OPEN CASCADE, EADS/CCR, LIP6, CEA/DEN,
//  CEDRAT, EDF R&D, LEG, PRINCIPIA R&D, BUREAU VERITAS 
// 
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public 
//  License as published by the Free Software Foundation; either 
//  version 2.1 of the License. 
// 
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free Software 
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA 
// 
//  See http://www.opencascade.org/SALOME/ or email : webmaster.salome@opencascade.org 
//
//
//
//  File   : MED.idl
//  $Header$

/*! 
This file contains the main IDL difinitions of the %MED component in %SALOME application.
*/
#ifndef MED_IDL
#define MED_IDL

#include "SALOME_Exception.idl"
#include "SALOME_Component.idl"
#include "SALOMEDS.idl"

module Engines {
  /*!
    An array of long
  */
  typedef sequence<long> long_array;
  /*!
    An array of double
  */
  typedef sequence<double> double_array;
  /*!
    An array of string
  */
  typedef sequence<string> string_array;
  /*!
    An array of boolean
  */
  typedef sequence<boolean> boolean_array;

};
/*! 
This package contains a set of interfaces used for %SALOME %MED component.
*/ 

module SALOME_MED {

  //  interface FIELD;
  interface FIELD;
  interface FAMILY;
  interface GROUP;
  interface MESH;
  interface SUPPORT;

/*! 
This enumeration conatains a set of elements difining the type of geometrical elements which constitue 
a %Mesh.
*/
  enum medGeometryElement {
    MED_NONE,
    MED_POINT1,
    MED_SEG2,
    MED_SEG3,
    MED_TRIA3,
    MED_QUAD4,
    MED_TRIA6,
    MED_QUAD8,
    MED_TETRA4,
    MED_PYRA5,
    MED_PENTA6,
    MED_HEXA8,
    MED_TETRA10,
    MED_PYRA13,
    MED_PENTA15,
    MED_HEXA20,
    MED_ALL_ELEMENTS
  };
/*! 
This enumeration conatains a set of elements difining the structural elements (entities) which constitue 
a %Mesh.
*/

  enum medEntityMesh {
    MED_CELL,
    MED_FACE,
    MED_EDGE,
    MED_NODE,
    MED_ALL_ENTITIES
  };

  enum medModeSwitch {
    MED_FULL_INTERLACE,
    MED_NO_INTERLACE
  };

  enum medConnectivity {
    MED_NODAL,
    MED_DESCENDING
  };
/*! 
This enumeration conatains a set of elements difining the type of driver.
*/

  enum medDriverTypes {
    MED_DRIVER , /*!<This driver is used for reading into memory of the mesh from %MED file.*/
    VTK_DRIVER , /*!<This driver is used for visualization of the mesh imported from %MED file.*/
    NO_DRIVER    
  };

  /*!
    An array of <VAR>medGeometryElement</VAR>
  */
  typedef sequence<medGeometryElement> medGeometryElement_array;
  /*!
    An array of %FAMILY
  */
  typedef sequence<FAMILY> Family_array;
  /*!
    An array of %GROUP
  */
  typedef sequence<GROUP> Group_array;
  
  // ----------------------
  // mesh interface
  // ----------------------

  interface MESH {
    // Index range begins from 1

    // General Informations
    //---------------------

    /*!
      Returns the name of the mesh .
    */
    string getName() raises (SALOME::SALOME_Exception);
    
    /*!
      Returns space dimension.
    */
    long getSpaceDimension() raises (SALOME::SALOME_Exception);

    /*!
      Returns mesh dimension.
      
      Example :
      - we have only MED_TETRA4 in MED_CELL : MeshDimension = 3D
      - we have only MED_QUAD4 in MED_CELL : MeshDimension = 2D
      - we have both MED_SEG2 and MED_TRIA3 in MED_CELL : MeshDimension = 2D
    */
    long getMeshDimension() raises (SALOME::SALOME_Exception);

    // Coordinates
    //------------

    /*!
      Returns coordinate system :
      - "CARTESIAN"
      - "CYLINDRICAL"
      - "SPHERICAL"
    */
    string getCoordinateSystem() raises (SALOME::SALOME_Exception); 

    /*!
      Returns the number of nodes defined in the mesh.
    */
    long getNumberOfNodes() raises (SALOME::SALOME_Exception);

    /*!
      Returns an array of coordinates  :
      - X1,Y1,Z1,X2,Y2,...,Zn if MED_FULL_INTERLACE
      - X1,X2,...Xn,Y1,Y2,...Zn if MED_NO_INTERLACE
    */
    Engines::double_array getCoordinates(in medModeSwitch typeSwitch)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns an array containing the names of coordinates.
      
      Example :
      - x,y,z
      - r,teta,phi
      - ...
      
      It could be empty.
    */
    Engines::string_array getCoordinatesNames()
      raises (SALOME::SALOME_Exception);

    /*!
      Returns an array containing the units of coordinates (cm, m, mm, ...)

      It could be empty. By defult IS is used (meter).
    */
    Engines::string_array getCoordinatesUnits()
      raises (SALOME::SALOME_Exception);

    // Connectivity
    // ------------

    /*!
      Returns the number of different <VAR>medGeometryElement</VAR> types existing 
      in the specified entity.

      \note 
      Not implemented for MED_ALL_ENTITIES.
    */
    long getNumberOfTypes(in medEntityMesh entity)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns an array of all <VAR>medGeometryElement</VAR> types existing 
      in the mesh.

      \note 
       Not implemented for MED_ALL_ENTITIES.
    */
    medGeometryElement_array getTypes(in medEntityMesh entity)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns the number of elements of type <VAR>medGeometryElement</VAR>.

      Note : 
      - Implemented for MED_ALL_ELEMENTS
      - Not implemented for MED_ALL_ENTITIES
    */
    long getNumberOfElements(in medEntityMesh entity,
			     in medGeometryElement geomElement)
      raises (SALOME::SALOME_Exception);

    /*!
      Give, in full or no interlace mode (for nodal connectivity),
      descending or nodal connectivity.

      You must give a <VAR>medEntityMesh</VAR> (ie:MED_EDGE) and a 
      <VAR>medGeometryElement</VAR> (ie:MED_SEG3).
    */
    Engines::long_array getConnectivity(in medModeSwitch typeSwitch,
					in medConnectivity mode,
					in medEntityMesh entity,
					in medGeometryElement geomElement)
      raises (SALOME::SALOME_Exception);

    /*!
      Give morse index array to use with 
      getConnectivity(MED_FULL_INTERLACE,mode,entity,MED_ALL_ELEMENTS).

      Each value give start index for corresponding entity in 
      connectivity array.

      Example : i-th element, j-th node of it :
      - In C mode : Connectivity[ConnectivityIndex[i]-1+j-1]
      - In fortran mode : Connectivity[ConnectivityIndex[i]+j]
    */
    Engines::long_array getConnectivityIndex(in medConnectivity mode,
					     in medEntityMesh entity)
      raises (SALOME::SALOME_Exception);

    /*!
      Gets a global number of the element which have the same connectivity as the  
      connectivity argument.
    */
    long getElementNumber(in medConnectivity mode, 
			  in medEntityMesh entity, 
			  in medGeometryElement type, 
			  in Engines::long_array connectivity) 
      raises (SALOME::SALOME_Exception);

    /*!
      Returns a reverse connectivity to MED_CELL.

      If mode=MED_NODAL, the array contains, for each node, all cells 
      arround it.

      If mode=MED_DESCENDING, the array contains, for each face (or edge), 
      the 2 cells of each side. First is cell which face normal is outgoing.
    */
    Engines::long_array getReverseConnectivity(in medConnectivity mode)
      raises (SALOME::SALOME_Exception);

    /*!
      Give index array to use with getReverseConnectivity(MED_NODAL).

      This method is not used with MED_DESCENDING mode, 
      because we have allways two cells.

      See getConnectivityIndex for details.
    */
    Engines::long_array getReverseConnectivityIndex(in medConnectivity mode)
      raises (SALOME::SALOME_Exception);

    // Families and Groups
    // -------------------

    /*!
      Returns the number of all families.
    */
    long getNumberOfFamilies(in medEntityMesh entity)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns the number of all groups.
    */
    long getNumberOfGroups(in medEntityMesh entity)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns an array of all families.
    */
    Family_array getFamilies(in medEntityMesh entity)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns the reference to i-th family.

      \note 
      i is bounded by 1 and NumberOfFamilies.
    */
    FAMILY getFamily(in medEntityMesh entity,in long familyNumber)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns an array of all groups.
    */
    Group_array getGroups(in medEntityMesh entity)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns the reference to i-th group.

      \note 
     i is bounded by 1 and NumberOfGroups.
    */
    GROUP getGroup(in medEntityMesh entity,in long groupNumber)
      raises (SALOME::SALOME_Exception);

    // Others
    // ------

    /*!
      Returns a field on mySupport containing volume.

      \note 
      mySupport must be on MED_CELL entity and MeshDimension must be 3D.
    */
    FIELD getVolume(in SUPPORT mySupport)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns a field on mySupport containing area.

      \note 
      mySupport must be on MED_FACE entity.
    */
    FIELD getArea(in SUPPORT mySupport)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns a field on mySupport containing length.

    \note
     mySupport must be on MED_EDGE entity.
    */
    FIELD getLength(in SUPPORT mySupport)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns a field on mySupport containing normal.

      \note
      mySupport must be on MED_FACE entity if MeshDimension and 
      SpaceDimension=3D and on MED_EDGE if MeshDimension and SpaceDimension=2D.
    */
    FIELD getNormal(in SUPPORT mySupport)
      raises (SALOME::SALOME_Exception);

    /*!
      Returns a field on mySupport containing barycenter.
    */
    FIELD getBarycenter(in SUPPORT mySupport)
      raises (SALOME::SALOME_Exception);

    /*
      Returns a field on mySupport containing neighbourhood.
    */
    // FIELD getNeighbourhood(in SUPPORT mySupport)
    // raises (SALOME::SALOME_Exception);

    // Read & Write
    // -----------

    /*!
      Adds the Mesh in the StudyManager.
    */
    void addInStudy(in SALOMEDS::Study myStudy, in MESH myIor )
      raises (SALOME::SALOME_Exception, SALOMEDS::StudyBuilder::LockProtection);

    // 		                Add a MED/VTK/... driver
    //                          Multiple drivers can be added whatever the type
    long addDriver     (in medDriverTypes driverType, in string  fileName, in string meshName) 
                                        raises (SALOME::SALOME_Exception);
    //                          Remove a driver
    void rmDriver      (in long i)  raises (SALOME::SALOME_Exception);

   //
    void read          (in long i)  raises (SALOME::SALOME_Exception);
    void write         (in long i, in string driverMeshName)  
                                    raises (SALOME::SALOME_Exception);
  
/*!
Internal Corba method. 
*/ 
    long getCorbaIndex() 	raises (SALOME::SALOME_Exception);
  };

  
  // ----------------------
  // Support interface
  // ----------------------
  
  interface SUPPORT {
    
    /*!
      Returns the name of the support.
    */
    string getName() raises (SALOME::SALOME_Exception);

    /*!
      Returns the description of the support.
    */
    string getDescription() raises (SALOME::SALOME_Exception);

    /*!
      Returns a reference to the mesh.
    */
    MESH getMesh() raises (SALOME::SALOME_Exception);

    /*!
      Returns the type of <VAR>medEntityMesh</VAR> used by the support. 

      \note 
      A support deals only with one entity's type 
      (for example : MED_FACE or MED_NODE)
    */
    medEntityMesh getEntity() raises (SALOME::SALOME_Exception);

    /*!
      Returns True if all elements of this entity are
      engaged, False otherwise.

      If True, you must use mesh reference (getMesh) to get more information.
    */
    boolean isOnAllElements() raises (SALOME::SALOME_Exception);

    /*!
      If the method <VAR>isOnAllElements</VAR> returns False, this method 
     returns the number of elements in the support.

      Example : number of MED_TRIA3 or MED_ALL_ELEMETNS elements 
      in entity of support.

      \note 
      If %SUPPORT is defined on MED_NODE, use MED_NONE <VAR>medGeometryElement</VAR> type.
    */
    long getNumberOfElements(in medGeometryElement geomElement)
      raises (SALOME::SALOME_Exception);

    /*!
      If isOnAllElements is False, returns an array of <VAR>medGeometryElement</VAR>
      types used by the support.

      <VAR>medEntityMesh</VAR> is given by getEntity.
    */
    medGeometryElement_array getTypes() raises (SALOME::SALOME_Exception);

    /*!
      If the method <VAR>isOnAllElements</VAR> returns False, this method returns an array which 
     contains all numbers of given <VAR>medGeometryElement</VAR>.

      Numbering is global, ie numbers are bounded by 1 and 
      MESH::getNumberOfElement(entity,MED_ALL_ELEMENTS) and not by 1 and 
      MESH::getNumberOfElement(entity,geomElement).

      \note
      If %SUPPORT is defined on MED_NODE, use MED_NONE <VAR>medGeometryElement</VAR> type.
    */
    Engines::long_array getNumber(in medGeometryElement geomElement)
      raises (SALOME::SALOME_Exception);

    /*!
      If the method <VAR>isOnAllElements</VAR> returns False, this method returns the index 
      of element number.
      
      Use it with getNumber(MED_ALL_ELEMENTS). 
      
      \note 
       See the method <VAR>getConnectivityIndex</VAR> for more details.
    */
    Engines::long_array getNumberIndex()
      raises (SALOME::SALOME_Exception);
    /*!
      Returns the number of Gauss points for this <VAR>medGeometryElement</VAR>.

      \note 
      - Not defined if %SUPPORT is on MED_NODE.
      - Not defined for MED_ALL_ELEMENTS <VAR>medGeometryElement</VAR> type.
     */
    long getNumberOfGaussPoints(in medGeometryElement geomElement)
      					raises (SALOME::SALOME_Exception);
/*!
Internal Corba method. 
*/    
    long getCorbaIndex() 	        raises (SALOME::SALOME_Exception);
  };


  //-----------------
  // Family interface
  //-----------------

  interface FAMILY : SUPPORT 
    {

      /*!
	Returns Family identifier (Identifier
	of the family in the mesh). 

	\note
      There is precisely only one indentifier for each family.
      */
      long getIdentifier() raises (SALOME::SALOME_Exception);

      /*!
	Returns number of attributes.
      */
      long getNumberOfAttributes() raises (SALOME::SALOME_Exception);

      /*!
	Returns an array of all attributes' identifiers.
	There is one for each attribute.
      */
      Engines::long_array getAttributesIdentifiers() 
	raises (SALOME::SALOME_Exception);

      /*!
	Returns identifier of i-th attribute.

	\note 
      i is bounded by 1 and NumberOfAttributes.
      */
      long getAttributeIdentifier(in long i) raises (SALOME::SALOME_Exception);

      /*!
	Returns an array of all values of the attributes .
	There is one value for each attribute.
      */
      Engines::long_array getAttributesValues() 
	raises (SALOME::SALOME_Exception);

      /*!
	Returns the value of i-th attribute.

	\note 
      i is bounded by 1 and NumberOfAttributes.
      */
      long getAttributeValue(in long i) raises (SALOME::SALOME_Exception);

      /*!
	Returns an array of all descriptions of the attributes .
	There is one description for each attribute.
      */
      Engines::string_array getAttributesDescriptions() 
	raises (SALOME::SALOME_Exception);

      /*!
	Returns the description of i-th attribute.

	\note 
      i is bounded by 1 and NumberOfAttributes.
      */
      string getAttributeDescription(in long i) 
	raises (SALOME::SALOME_Exception);
    };


  //----------------
  // Group interface
  //----------------
  interface GROUP : SUPPORT 
    {

      /*!
	Returns the number of families in this group.
      */
      long getNumberOfFamilies() raises (SALOME::SALOME_Exception);

      /*!
	Returns an array of all families.
      */
      Family_array getFamilies() raises (SALOME::SALOME_Exception);

      /*!
	Returns a reference to the i-th family.

	\note 
      i is bounded by 1 and NumberOfFamilies.
      */
      FAMILY getFamily(in long i) raises (SALOME::SALOME_Exception);

    };


  //----------------
  // Field interface
  //----------------

  interface FIELD 
    {

      /*!
	Returns the field name.
      */
      string getName() raises (SALOME::SALOME_Exception);

      /*!
	Returns the field description.
      */
      string getDescription() raises (SALOME::SALOME_Exception);

      /*!
	Returns a reference to the support
	on which the field is defined.
      */
      SUPPORT getSupport() raises (SALOME::SALOME_Exception);

      /*!
	Returns the number of field's components.
      */
      long getNumberOfComponents() raises (SALOME::SALOME_Exception);

      /*!
	Returns an array containing components names.
      */
      Engines::string_array getComponentsNames() 
	raises (SALOME::SALOME_Exception);

      /*!
	Returns the name of i-th component.

	\note  
	- i is bounded by 1 and NumberOfComponents.
	- Name is mandatory for each field's component.
      */
      string getComponentName(in long i) raises (SALOME::SALOME_Exception);

      /*!
	Returns an array containing components units.
      */
      Engines::string_array getComponentsUnits()
	raises (SALOME::SALOME_Exception);

      /*!
	Returns the unit of i-th component.

	\note 
      i is bounded by 1 and NumberOfComponents.
      */
      string getComponentUnit(in long i) raises (SALOME::SALOME_Exception);


      long getIterationNumber() raises (SALOME::SALOME_Exception);

      /*!
	Returns time for this iteration.
      */
      double getTime() raises (SALOME::SALOME_Exception);

      /*!
	Returns order number use for 
	internal step in this iteration.
      */
      long getOrderNumber() raises (SALOME::SALOME_Exception);

      // Read & Write
      // -----------
      
      long addDriver (in medDriverTypes driverType, in string  fileName, in string fieldName) 
	raises (SALOME::SALOME_Exception);
      
      /*!
     Removes a driver
     */
      void rmDriver (in long i)
	raises (SALOME::SALOME_Exception);
      
      //
      void read (in long i)
	raises (SALOME::SALOME_Exception);

      /*!
	Writes a field.
      */
      void write (in long i, in string driverFieldName)  
	raises (SALOME::SALOME_Exception);
      
      /*!
	Adds the Field in the StudyManager.
      */
      void addInStudy(in SALOMEDS::Study myStudy, in FIELD myIor )
	raises (SALOME::SALOME_Exception, SALOMEDS::StudyBuilder::LockProtection);

/*!
Internal Corba method.
*/
      long getCorbaIndex()
	raises (SALOME::SALOME_Exception);

    };


  interface FIELDDOUBLE : FIELD {

    /*!
      Returns an array of values of the field  
    */
    Engines::double_array getValue(in medModeSwitch mode)
      raises (SALOME::SALOME_Exception);
  };

  interface FIELDINT : FIELD {

    /*!
      Returns an array of values of the field  
    */
    Engines::long_array getValue(in medModeSwitch mode)
      raises (SALOME::SALOME_Exception);

  };

  // MED interface

  interface MED {


    long                   getNumberOfMeshes () raises (SALOME::SALOME_Exception);       
    long                   getNumberOfFields () raises (SALOME::SALOME_Exception);
    Engines::string_array  getMeshNames      () raises (SALOME::SALOME_Exception);
    Engines::string_array  getFieldNames     () raises (SALOME::SALOME_Exception);
    MESH                   getMeshByName     ( in string  meshName)  raises (SALOME::SALOME_Exception);
    MESH                   getMesh           ( in FIELD  fieldPtr)   raises (SALOME::SALOME_Exception);
    FIELD                  getField          ( in string fieldName, 
					       in long pasTemps,
					       in long numOrdre )    raises (SALOME::SALOME_Exception);


    // Add a MED/VTK/... driver to a MED'GEN' object to 
    // be able to read/write files preserving  meshes<-->fields association
    // Multiple drivers can be added whatever the type.
    // The access point in the <long> returned
    long addDriver     (in medDriverTypes driverType, in string  fileName) 
                                        raises (SALOME::SALOME_Exception);
    /*! 
   Removes the driver
    */ 
    void rmDriver      (in long i)  raises (SALOME::SALOME_Exception);
    /*! 
    Reads the structure of the %MED file
    */
    void readFileStruct(in long i)  raises (SALOME::SALOME_Exception);
    void writeFrom     (in long i)  raises (SALOME::SALOME_Exception);
    void write         (in long i)  raises (SALOME::SALOME_Exception);

    void addMesh  (in MESH   ptrMesh   ) raises (SALOME::SALOME_Exception);
    void addField (in FIELD  ptrField  ) raises (SALOME::SALOME_Exception);
    
    void addInStudy (in SALOMEDS::Study myStudy, in MED medPtr) raises (SALOME::SALOME_Exception, SALOMEDS::StudyBuilder::LockProtection);
  };
};

#endif /* MED_IDL */
